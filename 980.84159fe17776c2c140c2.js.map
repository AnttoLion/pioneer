{"version":3,"file":"980.84159fe17776c2c140c2.js","mappings":"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","sources":["webpack://@joystream/pioneer/webpack/runtime/chunk loaded","webpack://@joystream/pioneer/webpack/runtime/startup chunk dependencies","webpack://@joystream/pioneer/./src/common/utils/bn.ts","webpack://@joystream/pioneer/./src/common/utils.ts","webpack://@joystream/pioneer/./src/common/logger/error.ts","webpack://@joystream/pioneer/./src/common/utils/proxy.ts","webpack://@joystream/pioneer/./src/proxyApi/models/payload.ts","webpack://@joystream/pioneer/./src/proxyApi/worker/query.ts","webpack://@joystream/pioneer/./src/proxyApi/worker/tx.ts","webpack://@joystream/pioneer/./src/proxyApi/worker/index.ts","webpack://@joystream/pioneer/./src/common/utils/rx.ts","webpack://@joystream/pioneer/webpack/bootstrap","webpack://@joystream/pioneer/webpack/runtime/compat get default export","webpack://@joystream/pioneer/webpack/runtime/define property getters","webpack://@joystream/pioneer/webpack/runtime/ensure chunk","webpack://@joystream/pioneer/webpack/runtime/get javascript chunk filename","webpack://@joystream/pioneer/webpack/runtime/global","webpack://@joystream/pioneer/webpack/runtime/hasOwnProperty shorthand","webpack://@joystream/pioneer/webpack/runtime/make namespace object","webpack://@joystream/pioneer/webpack/runtime/node module decorator","webpack://@joystream/pioneer/webpack/runtime/publicPath","webpack://@joystream/pioneer/webpack/runtime/importScripts chunk loading","webpack://@joystream/pioneer/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn Promise.all([\n\t\t__webpack_require__.e(487),\n\t\t__webpack_require__.e(906)\n\t]).then(next);\n};","import { BN_TEN, BN_TWO, BN_ZERO } from '@polkadot/util'\nimport BN from 'bn.js'\n\ntype BNParam = number | string | number[] | Uint8Array | Buffer | BN\n\nexport const sumStakes = (entities: { stake: BNParam }[]) =>\n  entities.reduce((total, { stake }) => total.add(new BN(stake)), BN_ZERO)\n\nexport const asBN = (value: any) => new BN(String(value))\n\nexport const sumBN = (a: BN | undefined, b: BN | undefined): BN => new BN(a ?? 0).add(new BN(b ?? 0))\n\nexport const powerOf10 = (value: any) => BN_TEN.pow(asBN(value))\n\nexport const powerOf2 = (value: any) => BN_TWO.pow(asBN(value))\n","export * from './utils/bn'\n\nimport { Reducer } from './types/helpers'\n\ntype Obj = Record<string, any>\n\n// Type guards\n\nexport const isFunction = (something: unknown): something is CallableFunction => typeof something === 'function'\n\nexport const isDefined = <T extends any>(something: T | undefined): something is T => typeof something !== 'undefined'\n\nexport const isNumber = (something: unknown): something is number => typeof something === 'number'\n\nexport const isString = (something: unknown): something is string => typeof something === 'string'\n\nexport const isRecord = (something: unknown): something is Obj => typeof something === 'object' && something !== null\n\nexport const whenDefined = <T extends any, R>(something: T | undefined, fn: (something: T) => R): R | undefined => {\n  if (isDefined(something)) return fn(something)\n}\n\n// Type Casting:\n\nexport const toNumber = (value: any): number => value?.toNumber?.() ?? (isNumber(value) ? value : NaN)\n\n// Math:\n\nexport const clamp = (min: number, value: number, max: number) => Math.max(min, Math.min(max, value))\n\n// Objects:\n\ninterface EqualsOption {\n  checkExtraKeys?: boolean\n  depth?: boolean | number\n}\n\nexport const objectEquals = <T extends Obj>(\n  reference: T,\n  { checkExtraKeys = false, depth = 1 }: EqualsOption = {}\n): ((compared: T) => boolean) => {\n  const equalsOption = { checkExtraKeys, depth: isNumber(depth) ? depth - 1 : depth }\n  const expectedKeys: Array<keyof T> = Object.keys(reference)\n  return (compared) =>\n    (!checkExtraKeys || expectedKeys.length === Object.keys(compared).length) &&\n    expectedKeys.every((key) => equals(compared[key], equalsOption)(reference[key]))\n}\n\nexport const equals = <T extends any>(\n  reference: T,\n  { depth = 1, ...option }: EqualsOption = {}\n): ((compared: T) => boolean) => {\n  if (depth > 0 && isRecord(reference)) {\n    const isEqual = objectEquals(reference, { depth, ...option })\n    return (compared) => isRecord(compared) && isEqual(compared)\n  } else {\n    return (compared) => compared === reference\n  }\n}\n\nexport const merge = <A extends Obj, B extends Obj = Partial<A>>(a: A, b: B): A & B => ({ ...a, ...b })\n\nexport const propsEquals =\n  <T extends Obj>(...keys: (keyof T)[]) =>\n  (a: T, b: T) =>\n    keys.every((key) => a[key] === b[key])\n\nexport const definedValues = <T extends Record<any, any>>(obj: T): T =>\n  Object.fromEntries(Object.entries(obj).flatMap(([key, value]) => (isDefined(value) ? [[key, value]] : []))) as T\n\n// Lists:\n\nexport const dedupeObjects = <T>(list: T[], options?: EqualsOption): T[] =>\n  list.reduce((remain: T[], item) => [...remain, ...(remain.some(objectEquals(item, options)) ? [] : [item])], [])\n\nexport const intersperse = <T extends any, S extends any>(\n  list: T[],\n  toSeparator: (index: number, list: T[]) => S\n): (T | S)[] =>\n  list.length < 2 ? list : [list[0], ...list.slice(1).flatMap((item, index) => [toSeparator(index, list), item])]\n\nexport const partition = <T extends any>(list: T[], predicate: (x: T) => boolean): [T[], T[]] =>\n  list.reduce(\n    ([pass, fail]: [T[], T[]], item): [T[], T[]] =>\n      predicate(item) ? [[...pass, item], fail] : [pass, [...fail, item]],\n    [[], []]\n  )\n\nexport const repeat = <T extends any>(getItem: (index: number) => T, times: number): T[] =>\n  Array.from({ length: times }, (_, i) => getItem(i))\n\nexport const debounce = <T extends (...params: any[]) => any>(fn: T, delay = 400) => {\n  type Result = (ReturnType<T> extends Promise<infer U> ? U : ReturnType<T>) | undefined\n  let latestTimeout: ReturnType<typeof setTimeout> | undefined\n\n  return (...params: Parameters<T>) =>\n    new Promise<Result>((resolve) => {\n      const resolveImmediately = !latestTimeout\n\n      const timeout = setTimeout(() => {\n        if (timeout !== latestTimeout) {\n          !resolveImmediately && resolve(undefined)\n        } else {\n          latestTimeout = undefined\n          !resolveImmediately && resolve(fn(...params))\n        }\n      }, delay)\n      latestTimeout = timeout\n\n      resolveImmediately && resolve(fn(...params))\n    })\n}\n\nexport const last = <T extends any>(list: ArrayLike<T>): T => list[list.length - 1]\nexport const flatten = <T extends any>(nested: (T | T[])[]) => ([] as T[]).concat(...nested)\n\nexport const groupBy = <T extends any>(list: T[], predicate: (prev: T, item: T, index: number) => boolean): T[][] => {\n  if (!list.length) return []\n\n  const groupByReducer: Reducer<T[][], T> = ([[prev, ...restI1], ...rest], item, index) =>\n    predicate(prev, item, index) ? [[item, prev, ...restI1], ...rest] : [[item], [prev, ...restI1], ...rest]\n\n  const [first, ...rest] = list\n  return rest.reduce(groupByReducer, [[first]]).reverse()\n}\n\nexport const asArray = <T extends any>(item: undefined | T): T[] => (isDefined(item) ? [item] : [])\n\ntype Item = Record<string, any>\n\nexport const arrayGroupBy = (items: Item[], key: keyof Item) =>\n  items.reduce(\n    (result, item) => ({\n      ...result,\n      [item[key]]: [...(result[item[key]] || []), item],\n    }),\n    {}\n  )\n\n// Promises:\n\ntype MapperP<T, R> = (value: T, index: number, array: T[] | readonly T[]) => Promise<R>\nexport const mapP = <T, R>(list: T[] | readonly T[], mapper: MapperP<T, R>): Promise<R[]> =>\n  Promise.all(list.map(mapper))\n\nexport const flatMapP = async <T, R>(list: T[] | readonly T[], mapper: MapperP<T, R | R[]>): Promise<R[]> =>\n  Promise.all(flatten(await mapP(list, mapper)))\n","export const error = (message?: any, ...optionalParams: any[]) => console.error(message, ...optionalParams)\n","import { AnyObject } from '../types'\n\nexport interface RecursiveProxyHandler<T extends AnyObject> extends Omit<ProxyHandler<T>, 'get'> {\n  get(params: { target: T; path: string[]; value: any; property: string }): any\n  default?(params: { target: T; path: string[]; value: any; property: string }): any\n}\n\nexport const recursiveProxy = <T extends AnyObject>(\n  value: T,\n  handler: RecursiveProxyHandler<T>,\n  path: string[] = [],\n  target = value\n): T =>\n  typeof value !== 'object' && typeof value !== 'function'\n    ? value\n    : new Proxy(value, {\n        // TODO implement other handler methods with a path\n        get(_, property: string) {\n          const nextPath = [...path, property]\n          const nextValue = handler.get({ target, path: nextPath, value, property })\n          return handler.default && typeof nextValue === 'undefined'\n            ? handler.default({ target, path: nextPath, value, property })\n            : recursiveProxy(nextValue, handler, nextPath, target)\n        },\n      })\n","import { createType } from '@joystream/types'\nimport { TypeRegistry } from '@polkadot/types'\nimport { EventRecord } from '@polkadot/types/interfaces'\nimport { SpRuntimeDispatchError } from '@polkadot/types/lookup'\nimport { AnyTuple, Codec } from '@polkadot/types/types'\nimport BN from 'bn.js'\nimport { get, isArray, isFunction, startCase, uniqueId } from 'lodash'\nimport { filter, firstValueFrom, map, Observable } from 'rxjs'\n\nimport { error } from '@/common/logger'\nimport { DispatchedError } from '@/common/model/JoystreamNode'\nimport { AnyObject } from '@/common/types'\nimport { recursiveProxy } from '@/common/utils/proxy'\n\nimport { AnyMessage, PostMessage, ProxyPromisePayload, RawMessageEvent, TransactionsRecord } from '../types'\n\nexport interface WorkerProxyMessage {\n  messageType: 'proxy'\n  proxyId: string\n  method: string\n  payload: AnyTuple\n}\n\nexport interface ClientProxyMessage {\n  messageType: 'proxy'\n  proxyId: string\n  payload: ProxyPromisePayload\n}\n\nexport const serializePayload = (\n  payload: any,\n  messages?: Observable<WorkerProxyMessage>,\n  postMessage?: PostMessage<ClientProxyMessage>\n): any => {\n  const stack: AnyObject[] = []\n  const result = serializeValue(payload)\n\n  while (stack.length) {\n    const current = stack.pop() as AnyObject\n    if (Array.isArray(current)) {\n      for (let index = 0; index < current.length; index++) {\n        current[index] = serializeValue(current[index])\n      }\n    } else {\n      for (const key of Object.keys(current)) {\n        current[key] = serializeValue(current[key])\n      }\n    }\n  }\n\n  return result\n\n  function serializeValue(value: any) {\n    if (isFunction(value)) {\n      return undefined\n    } else if (typeof value !== 'object' || value === null) {\n      return value\n    } else if (isCodec(value)) {\n      return serializeCodec(value)\n    } else if (value instanceof BN) {\n      return { kind: 'BN', value: value.toArray() }\n    } else if (value.kind === 'SubmittableExtrinsicProxy') {\n      return { kind: value.kind, txId: value.txId }\n    } else if (isSigner(value)) {\n      return serializeProxy(value, {}, ['signPayload'], 'signer', messages, postMessage)\n    } else {\n      const result = isArray(value) ? [...value] : serializeObject(value)\n      stack.push(result)\n      return result\n    }\n  }\n}\n\nconst serializeObject = (value: Record<any, any>): Record<string, any> => {\n  try {\n    const properties = Object.getOwnPropertyNames(value)\n    if (properties.length > Object.keys(value).length) {\n      return Object.fromEntries(properties.map((key) => [key, value[key]]))\n    }\n  } catch (err) {\n    // Nothing\n  }\n  return { ...value }\n}\n\n// WARNING this mutate the serialized payload\nexport const deserializePayload = (\n  payload: any,\n  messages?: Observable<ClientProxyMessage>,\n  postMessage?: PostMessage<WorkerProxyMessage>,\n  transactionsRecord?: TransactionsRecord\n): any => {\n  const stack: AnyObject[] = []\n  const result = deserializeValue(payload)\n\n  while (stack.length) {\n    const current = stack.pop() as AnyObject\n    if (Array.isArray(current)) {\n      for (let index = 0; index < current.length; index++) {\n        current[index] = deserializeValue(current[index])\n      }\n    } else {\n      for (const key of Object.keys(current)) {\n        if ('value' in (Object.getOwnPropertyDescriptor(current, key) ?? {})) {\n          current[key] = deserializeValue(current[key])\n        }\n      }\n    }\n  }\n\n  return result\n\n  function deserializeValue(value: any) {\n    if (typeof value !== 'object' || value === null) {\n      return value\n    } else if ('kind' in value) {\n      switch (value.kind) {\n        case 'codec':\n          return 'properties' in value ? deserializeExtendedCodec(value) : deserializeCodec(value)\n        case 'BN':\n          return new BN(value.value)\n        case 'SubmittableExtrinsicProxy':\n          return transactionsRecord?.[value.txId]\n        case 'proxy':\n          return deserializeProxy(value.json, value.methods, value.proxyId, messages, postMessage)\n      }\n    }\n\n    stack.push(value)\n    return value\n  }\n}\n\nexport const deserializeMessage =\n  <Message extends AnyMessage>() =>\n  (source: Observable<RawMessageEvent>) =>\n    source.pipe(map(({ data }) => ({ ...data, payload: deserializePayload(data.payload) } as Message)))\n\nconst serializeProxy = (\n  obj: AnyObject,\n  json: AnyObject = {},\n  methods: string[] = [],\n  name = '',\n  messages?: Observable<WorkerProxyMessage>,\n  postMessage?: PostMessage<ClientProxyMessage>\n) => {\n  if (!messages || !postMessage) {\n    throw Error('Serializing proxies from the Web Worker is not supported yet')\n  }\n\n  const proxyId = uniqueId(`${name}.`)\n  messages.pipe(filter((message) => message.proxyId === proxyId)).subscribe(async ({ method, payload: params }) => {\n    try {\n      const result = await obj[method](...params)\n      postMessage({ messageType: 'proxy', proxyId, payload: { result } })\n    } catch (err: any) {\n      const error: string = err.message ?? String(err)\n      postMessage({ messageType: 'proxy', proxyId, payload: { error } })\n    }\n  })\n  return { kind: 'proxy', proxyId, json, methods }\n}\n\nconst deserializeProxy = (\n  json: any,\n  methods: string[],\n  proxyId: string,\n  messages?: Observable<ClientProxyMessage>,\n  postMessage?: PostMessage<WorkerProxyMessage>\n) => {\n  if (!messages || !postMessage) {\n    throw Error('Deserializing object is currently only supported from the Web Worker')\n  }\n\n  return new Proxy(json, {\n    get(json, prop: string) {\n      if (prop in json) {\n        return json[prop]\n      } else if (methods.includes(prop)) {\n        return async (...params: AnyTuple) => {\n          postMessage({ messageType: 'proxy', proxyId, method: prop, payload: params })\n          const { payload } = await firstValueFrom(messages.pipe(filter((message) => message.proxyId === proxyId)))\n          return payload.error ? Promise.reject(payload.error) : payload.result\n        }\n      }\n    },\n  })\n}\n\ninterface SerializedCodec {\n  kind: 'codec'\n  type: string\n  value: any\n  properties?: any\n}\n\nconst serializeCodec = (codec: Codec): SerializedCodec => {\n  const type = codec.toRawType()\n\n  if (!type) {\n    error('Unrecognized codec object', codec, codec.toHuman())\n  }\n\n  const serializedCodec: SerializedCodec = { kind: 'codec', type, value: codec.toJSON() }\n\n  if (isEventRecord(codec)) {\n    const { data, index, meta, method, section, typeDef } = codec.event\n    const serializedData = data.map((data) => {\n      const result = serializeCodec(data)\n      if (isDispatchError(data)) {\n        const error = serializePayload(findMetaError(data))\n        return { ...result, properties: { ...result.value, error } }\n      }\n      return result\n    })\n    const event = {\n      data: serializedData,\n      index: index.toJSON(),\n      meta: meta.toJSON(),\n      method,\n      section,\n      typeDef,\n    }\n    return { ...serializedCodec, properties: { event } }\n  }\n\n  const properties = (Object.getOwnPropertyNames(Object.getPrototypeOf(codec)) as (keyof Codec)[])\n    .map((key) => [key, codec[key]])\n    .filter(([, prop]) => !isFunction(prop))\n\n  return properties.length > 0\n    ? { ...serializedCodec, properties: serializePayload(Object.fromEntries(properties)) }\n    : serializedCodec\n}\n\nconst isDispatchError = (data: Codec): data is SpRuntimeDispatchError => {\n  const error = data as SpRuntimeDispatchError\n  const methods = ['isBadOrigin', 'isModule'] as const\n  return error.type && methods.every((method) => typeof error[method] === 'boolean')\n}\n\nconst findMetaError = (data: SpRuntimeDispatchError): DispatchedError => {\n  type ValidGetters = 'asModule' | 'asToken' | 'asArithmetic' | 'asTransactional'\n  const getter: `as${SpRuntimeDispatchError['type']}` = `as${data.type}`\n  const errorIndex = getter in data && data[getter as ValidGetters]\n  return errorIndex && !errorIndex.isEmpty\n    ? data.registry.findMetaError(errorIndex.toU8a())\n    : { section: 'Error', name: data.type, docs: [`${startCase(data.type)} error`] }\n}\n\nconst isCodec = (obj: any): obj is Codec => typeof obj?.registry === 'object' && obj.registry instanceof TypeRegistry\n\nconst isEventRecord = (codec: Codec): codec is EventRecord => 'event' in codec\n\nconst deserializeCodec = (serialized: SerializedCodec) => createType(serialized.type, serialized.value) as Codec\n\nconst deserializeExtendedCodec = (serialized: SerializedCodec) =>\n  recursiveProxy(deserializeCodec(serialized), {\n    get: ({ value, property }) => bindIfFunction(value[property], value),\n    default: ({ path }) => deserializePayload(get(serialized.properties, path)),\n  })\n\nconst bindIfFunction = (value: any, context: any) => (isFunction(value) ? value.bind(context) : value)\n\nconst isSigner = (obj: any) => typeof obj.signPayload === 'function' && typeof obj.signRaw === 'function'\n","import { ApiRx } from '@polkadot/api'\nimport { invoke } from 'lodash'\n\nimport { ApiQueryKinds, ClientQueryMessage, WorkerQueryMessage } from '../client/query'\nimport { PostMessage } from '../types'\n\nexport const query = <K extends ApiQueryKinds>(\n  apiKind: K,\n  api: ApiRx,\n  message: ClientQueryMessage<K>,\n  postMessage: PostMessage<WorkerQueryMessage<K>>\n) =>\n  invoke(api[apiKind], [message.module, ...message.path], ...message.payload).subscribe((payload: any) => {\n    postMessage({\n      messageType: apiKind,\n      callId: message.callId,\n      payload,\n    } as WorkerQueryMessage<K>)\n  })\n","import { ApiRx } from '@polkadot/api'\nimport { SubmittableExtrinsic } from '@polkadot/api/types'\nimport { AnyTuple } from '@polkadot/types/types'\nimport { catchError, map, Observable, of } from 'rxjs'\n\nimport { ClientTxMessage, TxModule, WorkerTxMessage } from '../client/tx'\nimport { PostMessage } from '../types'\n\nexport const transactionsRecord: Record<string, SubmittableExtrinsic<'rxjs'>> = {}\n\nexport const tx = <ModuleKey extends TxModule>(\n  api: ApiRx,\n  message: ClientTxMessage,\n  postMessage: PostMessage<WorkerTxMessage>\n) => {\n  if (message.method === 'transaction') {\n    const module = api.tx[message.module as ModuleKey]\n    const tx = module[message.txKey as keyof ApiRx['tx'][ModuleKey]]\n\n    if (typeof tx !== 'function') {\n      throw Error(`api.${message.module}.${message.txKey} is not a function`)\n    }\n\n    transactionsRecord[message.txId] = tx.apply(module, message.payload)\n  } else {\n    const transaction = transactionsRecord[message.txId]\n    const method = transaction[message.method.key] as (...params: AnyTuple) => Observable<any>\n\n    method\n      .apply(transaction, message.payload)\n      .pipe(\n        map((result) => ({ result })),\n        catchError((error) => of({ error }))\n      )\n      .subscribe((payload) =>\n        postMessage({\n          messageType: 'tx',\n          txId: message.txId,\n          callId: message.method.id,\n          payload,\n        })\n      )\n  }\n}\n","import '@joystream/types'\nimport { ApiRx, WsProvider } from '@polkadot/api'\nimport { BehaviorSubject, filter, first, fromEvent, share } from 'rxjs'\n\nimport { isDefined } from '@/common/utils'\nimport { firstWhere } from '@/common/utils/rx'\n\nimport { ClientProxyMessage, deserializeMessage, deserializePayload, serializePayload } from '../models/payload'\nimport { ClientMessage, PostMessage, RawClientMessageEvent, WorkerMessage } from '../types'\n\nimport { query } from './query'\nimport { transactionsRecord, tx } from './tx'\n\nconst apiObserver = new BehaviorSubject<ApiRx | undefined>(undefined)\n\nconst postMessage: PostMessage<WorkerMessage> = (message) =>\n  self.postMessage({ ...message, payload: serializePayload(message.payload) })\n\nconst messages = fromEvent<RawClientMessageEvent>(self, 'message')\n\nconst clientProxyMessage = messages.pipe(\n  filter(({ data }) => data.messageType === 'proxy'),\n  deserializeMessage<ClientProxyMessage>(),\n  share()\n)\n\nmessages.subscribe(({ data }) => {\n  const payload = deserializePayload(data.payload, clientProxyMessage, postMessage, transactionsRecord)\n  const message = { ...data, payload } as ClientMessage\n\n  if (message.messageType === 'init') {\n    const provider = new WsProvider(message.payload)\n    ApiRx.create({ provider })\n      .pipe(first())\n      .subscribe((api) => {\n        postMessage({ messageType: 'init', payload: { consts: api.consts } })\n        postMessage({ messageType: 'isConnected', payload: true })\n\n        api.on('connected', () => self.postMessage({ messageType: 'isConnected', payload: true }))\n        api.on('disconnected', () => self.postMessage({ messageType: 'isConnected', payload: false }))\n\n        apiObserver.next(api)\n      })\n  } else {\n    apiObserver.pipe(firstWhere(isDefined)).subscribe((api) => {\n      switch (message.messageType) {\n        case 'derive':\n          return query('derive', api as ApiRx, message, postMessage)\n\n        case 'query':\n          return query('query', api as ApiRx, message, postMessage)\n\n        case 'rpc':\n          return query('rpc', api as ApiRx, message, postMessage)\n\n        case 'tx':\n          return tx(api as ApiRx, message, postMessage)\n      }\n    })\n  }\n})\n","import { filter, first, MonoTypeOperatorFunction, Observable } from 'rxjs'\n\nexport const firstWhere =\n  <T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T> =>\n  (source: Observable<T>) =>\n    source.pipe(filter(predicate), first())\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [487,906], () => (__webpack_require__(69971)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".\" + {\"487\":\"ab506686d3237e9a0a77\",\"906\":\"a8b1c472a4237e3e06a3\"}[chunkId] + \".js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t980: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = this[\"webpackChunk_joystream_pioneer\"] = this[\"webpackChunk_joystream_pioneer\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","next","isDefined","something","recursiveProxy","value","handler","path","target","Proxy","get","_","property","nextPath","nextValue","default","serializePayload","payload","messages","postMessage","stack","result","serializeValue","length","current","pop","Array","isArray","index","key","Object","keys","isFunction","isCodec","serializeCodec","kind","toArray","txId","isSigner","serializeProxy","serializeObject","push","properties","getOwnPropertyNames","fromEntries","map","err","deserializePayload","transactionsRecord","deserializeValue","getOwnPropertyDescriptor","deserializeExtendedCodec","deserializeCodec","deserializeProxy","json","methods","proxyId","obj","name","Error","uniqueId","pipe","filter","message","subscribe","async","method","params","messageType","error","String","prop","includes","firstValueFrom","Promise","reject","codec","type","toRawType","optionalParams","console","toHuman","serializedCodec","toJSON","isEventRecord","data","meta","section","typeDef","event","isDispatchError","findMetaError","getPrototypeOf","every","getter","errorIndex","isEmpty","registry","toU8a","docs","startCase","serialized","bindIfFunction","context","bind","signPayload","signRaw","query","apiKind","api","invoke","module","callId","apiObserver","BehaviorSubject","undefined","self","fromEvent","clientProxyMessage","source","share","provider","Api","first","consts","on","predicate","tx","txKey","apply","transaction","catchError","of","id","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","loaded","__webpack_modules__","call","m","x","__webpack_exports__","O","chunkIds","fn","priority","notFulfilled","Infinity","i","fulfilled","j","splice","r","n","__esModule","d","a","definition","o","defineProperty","enumerable","f","e","chunkId","all","reduce","promises","u","g","globalThis","this","Function","window","prototype","hasOwnProperty","Symbol","toStringTag","nmd","paths","children","scriptUrl","importScripts","location","document","currentScript","src","scripts","getElementsByTagName","replace","p","installedChunks","chunkLoadingGlobal","parentChunkLoadingFunction","moreModules","runtime","then"],"sourceRoot":""}